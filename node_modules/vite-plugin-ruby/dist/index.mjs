var __assign = Object.assign;

// src/index.ts
import {relative as relative2, dirname, resolve as resolve2, join as join2} from "path";
import createDebugger2 from "debug";

// src/utils.ts
import {readFileSync} from "fs";

// src/constants.ts
var APP_ENV = process.env.RAILS_ENV || process.env.RACK_ENV || process.env.APP_ENV;
var ENV_PREFIX = "VITE_RUBY";
var ALL_ENVS_KEY = "all";
var KNOWN_CSS_EXTENSIONS = [
  "css",
  "less",
  "sass",
  "scss",
  "styl",
  "stylus",
  "pcss",
  "postcss"
];
var KNOWN_ENTRYPOINT_TYPES = [
  "html",
  "jsx?",
  "tsx?",
  ...KNOWN_CSS_EXTENSIONS
];
var CSS_EXTENSIONS_REGEX = new RegExp(`\\.(${KNOWN_CSS_EXTENSIONS.join("|")})$`);
var ENTRYPOINT_TYPES_REGEX = new RegExp(`\\.(${KNOWN_ENTRYPOINT_TYPES.join("|")})(\\?.*)?$`);

// src/utils.ts
function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
function screamCase(key) {
  return key.replace(/([a-z])([A-Z])/g, "$1_$2").toUpperCase();
}
function configOptionFromEnv(optionName) {
  return process.env[`${ENV_PREFIX}_${screamCase(optionName)}`];
}
function booleanOption(value) {
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  return value;
}
function withoutExtension(filename) {
  return filename.substr(0, filename.lastIndexOf("."));
}
function loadJsonConfig(filepath) {
  return JSON.parse(readFileSync(filepath, {encoding: "utf8", flag: "r"}));
}
function cleanConfig(object) {
  Object.keys(object).forEach((key) => {
    const value = object[key];
    if (value === void 0 || value === null)
      delete object[key];
    else if (isObject(value))
      cleanConfig(value);
  });
  return object;
}

// src/config.ts
import {join, relative, resolve} from "path";
import glob from "fast-glob";
var defaultConfig = loadJsonConfig(resolve(__dirname, "../default.vite.json"));
function resolveEntrypointFiles(entrypointsDir) {
  return glob.sync(`${entrypointsDir}/**/*`, {onlyFiles: true}).map((filename) => [relative(entrypointsDir, filename), filename]);
}
function resolveEntrypointsForRollup(entrypointsDir) {
  return resolveEntrypointFiles(entrypointsDir).filter(([_name, filename]) => ENTRYPOINT_TYPES_REGEX.test(filename)).map(([name, filename]) => [CSS_EXTENSIONS_REGEX.test(name) ? name : withoutExtension(name), filename]);
}
function resolveEntrypointAssets(entrypointsDir) {
  return resolveEntrypointFiles(entrypointsDir).filter(([_name, filename]) => !ENTRYPOINT_TYPES_REGEX.test(filename));
}
function configFromEnv() {
  const envConfig = {};
  Object.keys(defaultConfig).forEach((optionName) => {
    const envValue = configOptionFromEnv(optionName);
    if (envValue !== void 0)
      envConfig[optionName] = envValue;
  });
  return envConfig;
}
function loadConfiguration(viteMode, projectRoot2, userConfig) {
  const envConfig = configFromEnv();
  const mode = envConfig.mode || APP_ENV || viteMode;
  const filePath = join(projectRoot2, envConfig.configPath || defaultConfig.configPath);
  const multiEnvConfig = loadJsonConfig(filePath);
  const fileConfig = __assign(__assign({}, multiEnvConfig[ALL_ENVS_KEY]), multiEnvConfig[mode]);
  return coerceConfigurationValues(__assign(__assign(__assign(__assign({}, defaultConfig), fileConfig), envConfig), {mode}), projectRoot2, userConfig);
}
function coerceConfigurationValues(config2, projectRoot2, userConfig) {
  var _a;
  config2.port = parseInt(config2.port);
  config2.https = ((_a = userConfig.server) == null ? void 0 : _a.https) || booleanOption(config2.https);
  const buildOutputDir = join(config2.publicDir, config2.publicOutputDir);
  config2.root = join(projectRoot2, config2.sourceCodeDir, config2.entrypointsDir);
  config2.outDir = relative(config2.root, buildOutputDir);
  const assetHost = config2.assetHost || "";
  const assetHostWithProtocol = assetHost && !assetHost.startsWith("http") ? `//${assetHost}` : assetHost;
  config2.base = `${assetHostWithProtocol}/${config2.publicOutputDir}/`;
  return config2;
}

// src/manifest.ts
import path from "path";
import {promises as fsp} from "fs";
import {createHash} from "crypto";
import createDebugger from "debug";
var debug = createDebugger("vite-plugin-ruby:assets-manifest");
function getAssetHash(content) {
  return createHash("sha256").update(content).digest("hex").slice(0, 8);
}
function assetsManifestPlugin() {
  let config2;
  function extractChunkStylesheets(bundle, manifest) {
    const cssFiles = new Set(Object.values(config2.build.rollupOptions.input).filter((file) => CSS_EXTENSIONS_REGEX.test(file)).map((file) => path.relative(config2.root, file)));
    Object.values(bundle).filter((chunk) => chunk.type === "asset" && chunk.name).forEach((chunk) => {
      if (!config2.build.cssCodeSplit && chunk.name === "style.css")
        return manifest.set(chunk.name, {file: chunk.fileName, src: chunk.name});
      const src = withoutExtension(chunk.name);
      if (cssFiles.has(src))
        manifest.set(src, {file: chunk.fileName, src});
    });
  }
  async function fingerprintRemainingAssets(ctx, bundle, manifest) {
    const remainingAssets = resolveEntrypointAssets(config2.root);
    for (const [filename, absoluteFilename] of remainingAssets) {
      const content = await fsp.readFile(absoluteFilename);
      const hash = getAssetHash(content);
      const ext = path.extname(filename);
      const filenameWithoutExt = filename.slice(0, -ext.length);
      const hashedFilename = path.posix.join(config2.build.assetsDir, `${path.basename(filenameWithoutExt)}.${hash}${ext}`);
      manifest.set(filename, {file: hashedFilename, src: filename});
      if (!bundle[hashedFilename])
        ctx.emitFile({name: filename, fileName: hashedFilename, type: "asset", source: content});
    }
  }
  return {
    name: "vite-plugin-ruby:assets-manifest",
    apply: "build",
    enforce: "post",
    configResolved(resolvedConfig) {
      config2 = resolvedConfig;
    },
    async generateBundle(_options, bundle) {
      const manifest = new Map();
      extractChunkStylesheets(bundle, manifest);
      await fingerprintRemainingAssets(this, bundle, manifest);
      debug({manifest});
      this.emitFile({
        fileName: "manifest-assets.json",
        type: "asset",
        source: JSON.stringify(Object.fromEntries(manifest), null, 2)
      });
    }
  };
}

// src/index.ts
var projectRoot = configOptionFromEnv("root") || process.cwd();
var codeRoot;
var watchAdditionalPaths = [];
function ViteRubyPlugin() {
  return [
    {
      name: "vite-plugin-ruby",
      config,
      configureServer
    },
    assetsManifestPlugin()
  ];
}
var debug2 = createDebugger2("vite-plugin-ruby:config");
function config(userConfig, env) {
  var _a, _b;
  const config2 = loadConfiguration(env.mode, projectRoot, userConfig);
  const {assetsDir, base, outDir, host, https, port, root} = config2;
  const entrypoints = Object.fromEntries(resolveEntrypointsForRollup(root));
  const server = {host, https, port, strictPort: true, fsServe: {root: projectRoot}};
  const build = __assign(__assign({
    emptyOutDir: true,
    sourcemap: config2.mode !== "development"
  }, userConfig.build), {
    assetsDir,
    manifest: true,
    outDir,
    rollupOptions: {
      input: entrypoints,
      output: __assign({
        sourcemapPathTransform(relativeSourcePath, sourcemapPath) {
          return relative2(projectRoot, resolve2(dirname(sourcemapPath), relativeSourcePath));
        }
      }, (_b = (_a = userConfig.build) == null ? void 0 : _a.rollupOptions) == null ? void 0 : _b.output)
    }
  });
  debug2({base, build, root, server, entrypoints});
  codeRoot = resolve2(join2(projectRoot, config2.sourceCodeDir));
  watchAdditionalPaths = (config2.watchAdditionalPaths || []).map((glob2) => resolve2(projectRoot, glob2));
  const alias = {"~/": `${codeRoot}/`, "@/": `${codeRoot}/`};
  return cleanConfig({
    resolve: {alias},
    base,
    root,
    server,
    build,
    optimizeDeps: {
      exclude: ["vite-plugin-ruby"]
    }
  });
}
function configureServer(server) {
  server.watcher.add(`${codeRoot}/**/*`);
  server.watcher.add(watchAdditionalPaths);
}
export {
  ViteRubyPlugin as default,
  projectRoot
};
